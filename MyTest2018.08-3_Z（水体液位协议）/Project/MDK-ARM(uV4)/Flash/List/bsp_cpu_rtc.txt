; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_cpu_rtc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_cpu_rtc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\RTX\inc -I..\..\RTX\portable -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_cpu_rtc.crf ..\..\User\bsp\src\bsp_cpu_rtc.c]
                          THUMB

                          AREA ||i.Is_Leap_Year||, CODE, READONLY, ALIGN=1

                  Is_Leap_Year PROC
;;;109    */
;;;110    static uint8_t Is_Leap_Year(uint16_t _year)
000000  4601              MOV      r1,r0
;;;111    {                     
;;;112    	if (_year % 4 == 0) /* 必须能被4整除 */
000002  17ca              ASRS     r2,r1,#31
000004  eb017292          ADD      r2,r1,r2,LSR #30
000008  1092              ASRS     r2,r2,#2
00000a  ebb10282          SUBS     r2,r1,r2,LSL #2
00000e  d112              BNE      |L1.54|
;;;113    	{ 
;;;114    		if (_year % 100 == 0) 
000010  2064              MOVS     r0,#0x64
000012  fb91f2f0          SDIV     r2,r1,r0
000016  fb001012          MLS      r0,r0,r2,r1
00001a  b950              CBNZ     r0,|L1.50|
;;;115    		{ 
;;;116    			if (_year % 400 == 0)
00001c  f44f70c8          MOV      r0,#0x190
000020  fb91f2f0          SDIV     r2,r1,r0
000024  fb001012          MLS      r0,r0,r2,r1
000028  b908              CBNZ     r0,|L1.46|
;;;117    			{
;;;118    				return 1;	/* 如果以00结尾,还要能被400整除 */
00002a  2001              MOVS     r0,#1
                  |L1.44|
;;;119    			}
;;;120    			else 
;;;121    			{
;;;122    				return 0;   
;;;123    			}
;;;124    
;;;125    		}
;;;126    		else 
;;;127    		{
;;;128    			return 1;   
;;;129    		}
;;;130    	}
;;;131    	else 
;;;132    	{
;;;133    		return 0; 
;;;134    	}
;;;135    }      
00002c  4770              BX       lr
                  |L1.46|
00002e  2000              MOVS     r0,#0                 ;122
000030  e7fc              B        |L1.44|
                  |L1.50|
000032  2001              MOVS     r0,#1                 ;128
000034  e7fa              B        |L1.44|
                  |L1.54|
000036  2000              MOVS     r0,#0                 ;133
000038  e7f8              B        |L1.44|
;;;136    
                          ENDP


                          AREA ||i.RTC_CalcWeek||, CODE, READONLY, ALIGN=1

                  RTC_CalcWeek PROC
;;;294    */
;;;295    uint8_t RTC_CalcWeek(uint16_t _year, uint8_t _mon, uint8_t _day)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;296    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;297    	/*
;;;298    	蔡勒（Zeller）公式
;;;299    		历史上的某一天是星期几？未来的某一天是星期几？关于这个问题，有很多计算公式（两个通用计算公式和
;;;300    	一些分段计算公式），其中最著名的是蔡勒（Zeller）公式。
;;;301    	    即w=y+[y/4]+[c/4]-2c+[26(m+1)/10]+d-1
;;;302    
;;;303    		公式中的符号含义如下，
;;;304    	     w：星期；
;;;305    	     c：年的高2位，即世纪-1
;;;306    	     y：年（两位数）；
;;;307    	     m：月（m大于等于3，小于等于14，即在蔡勒公式中，某年的1、2月要看作上一年的13、14月来计算，
;;;308    	  	    比如2003年1月1日要看作2002年的13月1日来计算）；
;;;309    	     d：日；
;;;310    	     [ ]代表取整，即只要整数部分。
;;;311    
;;;312    	    算出来的W除以7，余数是几就是星期几。如果余数是0，则为星期日。
;;;313            如果结果是负数，负数求余数则需要特殊处理：
;;;314                负数不能按习惯的余数的概念求余数，只能按数论中的余数的定义求余。为了方便
;;;315            计算，我们可以给它加上一个7的整数倍，使它变为一个正数，然后再求余数
;;;316    
;;;317    		以2049年10月1日（100周年国庆）为例，用蔡勒（Zeller）公式进行计算，过程如下：
;;;318    		蔡勒（Zeller）公式：w=y+[y/4]+[c/4]-2c+[26(m+1)/10]+d-1
;;;319    		=49+[49/4]+[20/4]-2×20+[26× (10+1)/10]+1-1
;;;320    		=49+[12.25]+5-40+[28.6]
;;;321    		=49+12+5-40+28
;;;322    		=54 (除以7余5)
;;;323    		即2049年10月1日（100周年国庆）是星期5。
;;;324    	*/
;;;325    	uint8_t y, c, m, d;
;;;326    	int16_t w;
;;;327    
;;;328    	if (_mon >= 3)
00000a  2d03              CMP      r5,#3
00000c  db0c              BLT      |L2.40|
;;;329    	{
;;;330    		m = _mon;
00000e  46ac              MOV      r12,r5
;;;331    		y = _year % 100;
000010  2064              MOVS     r0,#0x64
000012  fb94f8f0          SDIV     r8,r4,r0
000016  fb004018          MLS      r0,r0,r8,r4
00001a  b2c1              UXTB     r1,r0
;;;332    		c = _year / 100;
00001c  2064              MOVS     r0,#0x64
00001e  fb94f0f0          SDIV     r0,r4,r0
000022  b2c2              UXTB     r2,r0
;;;333    		d = _day;
000024  4637              MOV      r7,r6
000026  e010              B        |L2.74|
                  |L2.40|
;;;334    	}
;;;335    	else	/* 某年的1、2月要看作上一年的13、14月来计算 */
;;;336    	{
;;;337    		m = _mon + 12;
000028  f105000c          ADD      r0,r5,#0xc
00002c  f0000cff          AND      r12,r0,#0xff
;;;338    		y = (_year - 1) % 100;
000030  1e60              SUBS     r0,r4,#1
000032  f04f0864          MOV      r8,#0x64
000036  fb90f9f8          SDIV     r9,r0,r8
00003a  fb080019          MLS      r0,r8,r9,r0
00003e  b2c1              UXTB     r1,r0
;;;339    		c = (_year - 1) / 100;
000040  1e60              SUBS     r0,r4,#1
000042  fb90f0f8          SDIV     r0,r0,r8
000046  b2c2              UXTB     r2,r0
;;;340    		d = _day;
000048  4637              MOV      r7,r6
                  |L2.74|
;;;341    	}
;;;342    
;;;343    	w = y + y / 4 +  c / 4 - 2 * c + ((uint16_t)26*(m+1))/10 + d - 1;
00004a  f10c0901          ADD      r9,r12,#1
00004e  f04f0a1a          MOV      r10,#0x1a
000052  fb09f90a          MUL      r9,r9,r10
000056  f04f0a0a          MOV      r10,#0xa
00005a  fb99f9fa          SDIV     r9,r9,r10
00005e  ea4f7ae1          ASR      r10,r1,#31
000062  eb017a9a          ADD      r10,r1,r10,LSR #30
000066  eb010aaa          ADD      r10,r1,r10,ASR #2
00006a  ea4f7be2          ASR      r11,r2,#31
00006e  eb027b9b          ADD      r11,r2,r11,LSR #30
000072  eb0a0aab          ADD      r10,r10,r11,ASR #2
000076  f04f0b02          MOV      r11,#2
00007a  fb0baa12          MLS      r10,r11,r2,r10
00007e  44d1              ADD      r9,r9,r10
000080  44b9              ADD      r9,r9,r7
000082  f1a90901          SUB      r9,r9,#1
000086  fa0ff389          SXTH     r3,r9
;;;344    	if (w == 0)
00008a  b90b              CBNZ     r3,|L2.144|
;;;345    	{
;;;346    		w = 7;	/* 表示周日 */
00008c  2307              MOVS     r3,#7
00008e  e011              B        |L2.180|
                  |L2.144|
;;;347    	}
;;;348    	else if (w < 0)	/* 如果w是负数，则计算余数方式不同 */
000090  2b00              CMP      r3,#0
000092  da0a              BGE      |L2.170|
;;;349    	{
;;;350    		w = 7 - (-w) % 7;
000094  4258              RSBS     r0,r3,#0
000096  f04f0807          MOV      r8,#7
00009a  fb90f9f8          SDIV     r9,r0,r8
00009e  fb080019          MLS      r0,r8,r9,r0
0000a2  f1c00007          RSB      r0,r0,#7
0000a6  b203              SXTH     r3,r0
0000a8  e004              B        |L2.180|
                  |L2.170|
;;;351    	}
;;;352    	else
;;;353    	{
;;;354    		w = w % 7;
0000aa  2007              MOVS     r0,#7
0000ac  fb93f8f0          SDIV     r8,r3,r0
0000b0  fb003318          MLS      r3,r0,r8,r3
                  |L2.180|
;;;355    	}
;;;356    	return w;
0000b4  b2d8              UXTB     r0,r3
;;;357    }
0000b6  e8bd8ff0          POP      {r4-r11,pc}
;;;358    
                          ENDP


                          AREA ||i.RTC_ReadClock||, CODE, READONLY, ALIGN=2

                  RTC_ReadClock PROC
;;;205    */
;;;206    void RTC_ReadClock(void)
000000  b570              PUSH     {r4-r6,lr}
;;;207    {
;;;208    	static uint16_t daycnt = 0;
;;;209    	uint32_t timecount = 0; 
000002  2600              MOVS     r6,#0
;;;210    	uint32_t temp = 0;
000004  2400              MOVS     r4,#0
;;;211    	uint16_t temp1 = 0;
000006  2500              MOVS     r5,#0
;;;212    
;;;213    	timecount = RTC_GetCounter();     
000008  f7fffffe          BL       RTC_GetCounter
00000c  4606              MOV      r6,r0
;;;214    
;;;215    	temp = timecount / 86400;   /* 得到天数 */
00000e  4837              LDR      r0,|L3.236|
000010  fbb6f4f0          UDIV     r4,r6,r0
;;;216    
;;;217    	if (daycnt != temp)	/* 超过一天了 */
000014  4836              LDR      r0,|L3.240|
000016  8800              LDRH     r0,[r0,#0]  ; daycnt
000018  42a0              CMP      r0,r4
00001a  d03a              BEQ      |L3.146|
;;;218    	{       
;;;219    		daycnt = temp;
00001c  4934              LDR      r1,|L3.240|
00001e  800c              STRH     r4,[r1,#0]
;;;220    		temp1 = 1970;  /* 从1970年开始 */
000020  f24075b2          MOV      r5,#0x7b2
;;;221    
;;;222    		while (temp >= 365)
000024  e00e              B        |L3.68|
                  |L3.38|
;;;223    		{                          
;;;224    			if (Is_Leap_Year(temp1))	/* 是闰年 */
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       Is_Leap_Year
00002c  b130              CBZ      r0,|L3.60|
;;;225    			{
;;;226    				if (temp >= 366)
00002e  f5b47fb7          CMP      r4,#0x16e
000032  d302              BCC      |L3.58|
;;;227    				{
;;;228    					temp -= 366;		/* 闰年的秒钟数 */
000034  f5a474b7          SUB      r4,r4,#0x16e
000038  e002              B        |L3.64|
                  |L3.58|
;;;229    				}
;;;230    				else
;;;231    				{
;;;232    					//temp1++;		/* armfly: 这里闰年处理错误，不能加1 */
;;;233    					break;
00003a  e006              B        |L3.74|
                  |L3.60|
;;;234    				}  
;;;235                }
;;;236    			else 
;;;237    			{
;;;238    				temp -= 365;       /* 平年 */
00003c  f2a4146d          SUB      r4,r4,#0x16d
                  |L3.64|
;;;239    			}
;;;240    			temp1++;  
000040  1c68              ADDS     r0,r5,#1
000042  b285              UXTH     r5,r0
                  |L3.68|
000044  f5b47fb6          CMP      r4,#0x16c             ;222
000048  d8ed              BHI      |L3.38|
                  |L3.74|
00004a  bf00              NOP                            ;233
;;;241    		}   
;;;242    		g_tRTC.Year = temp1;	/* 得到年份 */
00004c  4829              LDR      r0,|L3.244|
00004e  8005              STRH     r5,[r0,#0]
;;;243    		
;;;244    		temp1 = 0;
000050  2500              MOVS     r5,#0
;;;245    		while (temp >= 28)	/* 超过了一个月 */
000052  e016              B        |L3.130|
                  |L3.84|
;;;246    		{
;;;247    			if(Is_Leap_Year(g_tRTC.Year) && temp1 == 1)	/* 当年是不是闰年/2月份 */
000054  4927              LDR      r1,|L3.244|
000056  8808              LDRH     r0,[r1,#0]  ; g_tRTC
000058  f7fffffe          BL       Is_Leap_Year
00005c  b130              CBZ      r0,|L3.108|
00005e  2d01              CMP      r5,#1
000060  d104              BNE      |L3.108|
;;;248    			{
;;;249    				if (temp >= 29)
000062  2c1d              CMP      r4,#0x1d
000064  d301              BCC      |L3.106|
;;;250    				{
;;;251    					temp -= 29;	/* 闰年的秒钟数 */
000066  3c1d              SUBS     r4,r4,#0x1d
000068  e009              B        |L3.126|
                  |L3.106|
;;;252    				}
;;;253    				else
;;;254    				{
;;;255    					break; 
00006a  e00c              B        |L3.134|
                  |L3.108|
;;;256    				}
;;;257                }
;;;258                else 
;;;259    			{
;;;260    				if (temp >= mon_table[temp1])
00006c  4822              LDR      r0,|L3.248|
00006e  5d40              LDRB     r0,[r0,r5]
000070  42a0              CMP      r0,r4
000072  d803              BHI      |L3.124|
;;;261    				{
;;;262    					temp -= mon_table[temp1];	/* 平年 */
000074  4820              LDR      r0,|L3.248|
000076  5d40              LDRB     r0,[r0,r5]
000078  1a24              SUBS     r4,r4,r0
00007a  e000              B        |L3.126|
                  |L3.124|
;;;263    				}
;;;264    				else 
;;;265    				{
;;;266    					break;
00007c  e003              B        |L3.134|
                  |L3.126|
;;;267    				}
;;;268    			}
;;;269    			temp1++;  
00007e  1c68              ADDS     r0,r5,#1
000080  b285              UXTH     r5,r0
                  |L3.130|
000082  2c1c              CMP      r4,#0x1c              ;245
000084  d2e6              BCS      |L3.84|
                  |L3.134|
000086  bf00              NOP                            ;255
;;;270    		}
;;;271    		g_tRTC.Mon = temp1 + 1;	/* 得到月份 */
000088  1c68              ADDS     r0,r5,#1
00008a  491a              LDR      r1,|L3.244|
00008c  7088              STRB     r0,[r1,#2]
;;;272    		g_tRTC.Day = temp + 1;  /* 得到日期 */
00008e  1c60              ADDS     r0,r4,#1
000090  70c8              STRB     r0,[r1,#3]
                  |L3.146|
;;;273    	}
;;;274    
;;;275    	temp = timecount % 86400;    /* 得到秒钟数 */
000092  4816              LDR      r0,|L3.236|
000094  fbb6f1f0          UDIV     r1,r6,r0
000098  fb006411          MLS      r4,r0,r1,r6
;;;276    
;;;277    	g_tRTC.Hour = temp / 3600;	/* 小时 */
00009c  f44f6061          MOV      r0,#0xe10
0000a0  fbb4f0f0          UDIV     r0,r4,r0
0000a4  4913              LDR      r1,|L3.244|
0000a6  7108              STRB     r0,[r1,#4]
;;;278    
;;;279    	g_tRTC.Min = (temp % 3600) / 60; /* 分钟 */
0000a8  f44f6061          MOV      r0,#0xe10
0000ac  fbb4f1f0          UDIV     r1,r4,r0
0000b0  fb004011          MLS      r0,r0,r1,r4
0000b4  213c              MOVS     r1,#0x3c
0000b6  fbb0f0f1          UDIV     r0,r0,r1
0000ba  490e              LDR      r1,|L3.244|
0000bc  7148              STRB     r0,[r1,#5]
;;;280    
;;;281    	g_tRTC.Sec = (temp % 3600) % 60; /* 秒钟 */
0000be  f44f6061          MOV      r0,#0xe10
0000c2  fbb4f1f0          UDIV     r1,r4,r0
0000c6  fb004011          MLS      r0,r0,r1,r4
0000ca  213c              MOVS     r1,#0x3c
0000cc  fbb0f2f1          UDIV     r2,r0,r1
0000d0  fb010012          MLS      r0,r1,r2,r0
0000d4  4907              LDR      r1,|L3.244|
0000d6  7188              STRB     r0,[r1,#6]
;;;282    
;;;283    	g_tRTC.Week = RTC_CalcWeek(g_tRTC.Year, g_tRTC.Mon, g_tRTC.Day);	/* 计算星期 */
0000d8  460b              MOV      r3,r1
0000da  78da              LDRB     r2,[r3,#3]  ; g_tRTC
0000dc  7899              LDRB     r1,[r3,#2]  ; g_tRTC
0000de  8818              LDRH     r0,[r3,#0]  ; g_tRTC
0000e0  f7fffffe          BL       RTC_CalcWeek
0000e4  4903              LDR      r1,|L3.244|
0000e6  71c8              STRB     r0,[r1,#7]
;;;284    }   
0000e8  bd70              POP      {r4-r6,pc}
;;;285    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L3.236|
                          DCD      0x00015180
                  |L3.240|
                          DCD      daycnt
                  |L3.244|
                          DCD      g_tRTC
                  |L3.248|
                          DCD      mon_table

                          AREA ||i.RTC_WriteClock||, CODE, READONLY, ALIGN=2

                  RTC_WriteClock PROC
;;;144    */
;;;145    uint8_t RTC_WriteClock(uint16_t _year, uint8_t _mon, uint8_t _day, uint8_t _hour, uint8_t _min, uint8_t _sec)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;146    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;147    	uint16_t t;
;;;148    	uint32_t seccount=0;
000010  2400              MOVS     r4,#0
;;;149    
;;;150    	if (_year < 2000 || _year > 2099)
000012  f5b66ffa          CMP      r6,#0x7d0
000016  db03              BLT      |L4.32|
000018  f6400033          MOV      r0,#0x833
00001c  4286              CMP      r6,r0
00001e  dd02              BLE      |L4.38|
                  |L4.32|
;;;151    	{
;;;152    		return 0;	/* _year范围1970-2099，此处设置范围为2000-2099 */   
000020  2000              MOVS     r0,#0
                  |L4.34|
;;;153    	}		
;;;154    	
;;;155    	for (t = 1970; t < _year; t++) 	/* 把所有年份的秒钟相加 */
;;;156    	{
;;;157    		if (Is_Leap_Year(t))		/* 判断是否为闰年 */
;;;158    		{
;;;159    			seccount += 31622400;	/* 闰年的秒钟数 */
;;;160    		}
;;;161    		else
;;;162    		{
;;;163    			seccount += 31536000; 	/* 平年的秒钟数 */
;;;164    		}
;;;165    	}
;;;166    
;;;167    	_mon -= 1;
;;;168    
;;;169    	for (t = 0; t < _mon; t++)         /* 把前面月份的秒钟数相加 */
;;;170    	{
;;;171    		seccount += (uint32_t)mon_table[t] * 86400;	/* 月份秒钟数相加 */
;;;172    
;;;173    		if (Is_Leap_Year(_year) && t == 1)
;;;174    		{
;;;175    			seccount += 86400;	/* 闰年2月份增加一天的秒钟数 */
;;;176    		}			
;;;177    	}
;;;178    
;;;179    	seccount += (uint32_t)(_day - 1) * 86400;	/* 把前面日期的秒钟数相加 */
;;;180    
;;;181    	seccount += (uint32_t)_hour * 3600;		/* 小时秒钟数 */
;;;182    
;;;183    	seccount += (uint32_t)_min * 60;	/* 分钟秒钟数 */
;;;184    
;;;185    	seccount += _sec;	/* 最后的秒钟加上去 */
;;;186    																	
;;;187    	PWR_BackupAccessCmd(ENABLE);	/* 必须要 */
;;;188    
;;;189    	RTC_WaitForLastTask();
;;;190    
;;;191    	RTC_SetCounter(seccount);
;;;192    
;;;193    	RTC_WaitForLastTask();			/* 必须加 PWR_BackupAccessCmd(ENABLE); 不然进入死循环 */
;;;194    
;;;195    	return 1;      
;;;196    }
000022  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.38|
000026  f24075b2          MOV      r5,#0x7b2             ;155
00002a  e00a              B        |L4.66|
                  |L4.44|
00002c  4628              MOV      r0,r5                 ;157
00002e  f7fffffe          BL       Is_Leap_Year
000032  b110              CBZ      r0,|L4.58|
000034  481e              LDR      r0,|L4.176|
000036  4404              ADD      r4,r4,r0              ;159
000038  e001              B        |L4.62|
                  |L4.58|
00003a  481e              LDR      r0,|L4.180|
00003c  4404              ADD      r4,r4,r0              ;163
                  |L4.62|
00003e  1c68              ADDS     r0,r5,#1              ;155
000040  b285              UXTH     r5,r0                 ;155
                  |L4.66|
000042  42b5              CMP      r5,r6                 ;155
000044  dbf2              BLT      |L4.44|
000046  1e78              SUBS     r0,r7,#1              ;167
000048  b2c7              UXTB     r7,r0                 ;167
00004a  2500              MOVS     r5,#0                 ;169
00004c  e010              B        |L4.112|
                  |L4.78|
00004e  481a              LDR      r0,|L4.184|
000050  5d40              LDRB     r0,[r0,r5]            ;171
000052  f24021a3          MOV      r1,#0x2a3             ;171
000056  4348              MULS     r0,r1,r0              ;171
000058  eb0414c0          ADD      r4,r4,r0,LSL #7       ;171
00005c  4630              MOV      r0,r6                 ;173
00005e  f7fffffe          BL       Is_Leap_Year
000062  b118              CBZ      r0,|L4.108|
000064  2d01              CMP      r5,#1                 ;173
000066  d101              BNE      |L4.108|
000068  4814              LDR      r0,|L4.188|
00006a  4404              ADD      r4,r4,r0              ;175
                  |L4.108|
00006c  1c68              ADDS     r0,r5,#1              ;169
00006e  b285              UXTH     r5,r0                 ;169
                  |L4.112|
000070  42bd              CMP      r5,r7                 ;169
000072  dbec              BLT      |L4.78|
000074  f1a80001          SUB      r0,r8,#1              ;179
000078  f24021a3          MOV      r1,#0x2a3             ;179
00007c  4348              MULS     r0,r1,r0              ;179
00007e  eb0414c0          ADD      r4,r4,r0,LSL #7       ;179
000082  ebc91049          RSB      r0,r9,r9,LSL #5       ;181
000086  ebc02009          RSB      r0,r0,r9,LSL #8       ;181
00008a  eb041400          ADD      r4,r4,r0,LSL #4       ;181
00008e  ebca100a          RSB      r0,r10,r10,LSL #4     ;183
000092  eb040480          ADD      r4,r4,r0,LSL #2       ;183
000096  445c              ADD      r4,r4,r11             ;185
000098  2001              MOVS     r0,#1                 ;187
00009a  f7fffffe          BL       PWR_BackupAccessCmd
00009e  f7fffffe          BL       RTC_WaitForLastTask
0000a2  4620              MOV      r0,r4                 ;191
0000a4  f7fffffe          BL       RTC_SetCounter
0000a8  f7fffffe          BL       RTC_WaitForLastTask
0000ac  2001              MOVS     r0,#1                 ;195
0000ae  e7b8              B        |L4.34|
;;;197    
                          ENDP

                  |L4.176|
                          DCD      0x01e28500
                  |L4.180|
                          DCD      0x01e13380
                  |L4.184|
                          DCD      mon_table
                  |L4.188|
                          DCD      0x00015180

                          AREA ||i.bsp_InitRTC||, CODE, READONLY, ALIGN=1

                  bsp_InitRTC PROC
;;;38     */
;;;39     void bsp_InitRTC(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;40     {
;;;41     	//uint16_t u16_WaitForOscSource;
;;;42     	
;;;43     	/* Enable PWR and BKP clocks */
;;;44     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);  
000002  2101              MOVS     r1,#1
000004  f04f50c0          MOV      r0,#0x18000000
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;45     
;;;46     	/* Allow access to BKP Domain */
;;;47     	PWR_BackupAccessCmd(ENABLE);	
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       PWR_BackupAccessCmd
;;;48     	
;;;49     	if (BKP_ReadBackupRegister(BKP_DR1)!=0xA5A5)
000012  2004              MOVS     r0,#4
000014  f7fffffe          BL       BKP_ReadBackupRegister
000018  f5a04125          SUB      r1,r0,#0xa500
00001c  39a5              SUBS     r1,r1,#0xa5
00001e  d032              BEQ      |L5.134|
;;;50     	{		
;;;51     		//			PWR_BackupAccessCmd(ENABLE);
;;;52     		/* Reset Backup Domain */
;;;53     		BKP_DeInit();
000020  f7fffffe          BL       BKP_DeInit
;;;54     
;;;55     		/* Enable LSE */
;;;56     		RCC_LSEConfig(RCC_LSE_ON);
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       RCC_LSEConfig
;;;57     		/* Wait till LSE is ready */
;;;58     		while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
00002a  bf00              NOP      
                  |L5.44|
00002c  2041              MOVS     r0,#0x41
00002e  f7fffffe          BL       RCC_GetFlagStatus
000032  2800              CMP      r0,#0
000034  d0fa              BEQ      |L5.44|
;;;59     		{}
;;;60     
;;;61     		/* Select LSE as RTC Clock Source */
;;;62     		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
000036  f44f7080          MOV      r0,#0x100
00003a  f7fffffe          BL       RCC_RTCCLKConfig
;;;63     
;;;64     		/* Enable RTC Clock */
;;;65     		RCC_RTCCLKCmd(ENABLE);
00003e  2001              MOVS     r0,#1
000040  f7fffffe          BL       RCC_RTCCLKCmd
;;;66     
;;;67     		/* Wait for RTC registers synchronization */
;;;68     		RTC_WaitForSynchro();
000044  f7fffffe          BL       RTC_WaitForSynchro
;;;69     
;;;70     		/* Wait until last write operation on RTC registers has finished */
;;;71     		RTC_WaitForLastTask();
000048  f7fffffe          BL       RTC_WaitForLastTask
;;;72     
;;;73     		RTC_WriteClock(2018, 8, 28, 18, 30, 0);
00004c  2000              MOVS     r0,#0
00004e  211e              MOVS     r1,#0x1e
000050  2312              MOVS     r3,#0x12
000052  221c              MOVS     r2,#0x1c
000054  e9cd1000          STRD     r1,r0,[sp,#0]
000058  2108              MOVS     r1,#8
00005a  f24070e2          MOV      r0,#0x7e2
00005e  f7fffffe          BL       RTC_WriteClock
;;;74     			
;;;75     		BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);
000062  f24a51a5          MOV      r1,#0xa5a5
000066  2004              MOVS     r0,#4
000068  f7fffffe          BL       BKP_WriteBackupRegister
;;;76     
;;;77     		/* Set RTC prescaler: set RTC period to 1sec */
;;;78     		RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
00006c  f64770ff          MOV      r0,#0x7fff
000070  f7fffffe          BL       RTC_SetPrescaler
;;;79     		//  RTC_SetPrescaler(16383); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
;;;80     		/* Wait until last write operation on RTC registers has finished */
;;;81     		RTC_WaitForLastTask();
000074  f7fffffe          BL       RTC_WaitForLastTask
;;;82     
;;;83     		/* Enable the RTC Second */
;;;84     		RTC_ITConfig(RTC_IT_SEC, ENABLE);
000078  2101              MOVS     r1,#1
00007a  4608              MOV      r0,r1
00007c  f7fffffe          BL       RTC_ITConfig
;;;85     
;;;86     		/* Wait until last write operation on RTC registers has finished */
;;;87     		RTC_WaitForLastTask();
000080  f7fffffe          BL       RTC_WaitForLastTask
000084  e009              B        |L5.154|
                  |L5.134|
;;;88     
;;;89     	} 
;;;90     	else
;;;91     	{
;;;92     		RTC_WaitForSynchro();
000086  f7fffffe          BL       RTC_WaitForSynchro
;;;93     		RTC_WaitForLastTask();
00008a  f7fffffe          BL       RTC_WaitForLastTask
;;;94     		/* Enable the RTC Second */
;;;95     		RTC_ITConfig(RTC_IT_SEC, ENABLE);
00008e  2101              MOVS     r1,#1
000090  4608              MOV      r0,r1
000092  f7fffffe          BL       RTC_ITConfig
;;;96     		RTC_WaitForLastTask();
000096  f7fffffe          BL       RTC_WaitForLastTask
                  |L5.154|
;;;97     	}	 	
;;;98     	
;;;99     	return;
;;;100    }
00009a  bd1c              POP      {r2-r4,pc}
;;;101    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  mon_table
000000  1f1c1f1e          DCB      0x1f,0x1c,0x1f,0x1e
000004  1f1e1f1f          DCB      0x1f,0x1e,0x1f,0x1f
000008  1e1f1e1f          DCB      0x1e,0x1f,0x1e,0x1f

                          AREA ||.data||, DATA, ALIGN=1

                  daycnt
000000  0000              DCW      0x0000
                  g_tRTC
000002  0000              DCB      0x00,0x00
                          DCDU     0x00000000
000008  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_cpu_rtc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_bsp_cpu_rtc_c_54b4358b____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_cpu_rtc_c_54b4358b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_bsp_cpu_rtc_c_54b4358b____REVSH|
#line 128
|__asm___13_bsp_cpu_rtc_c_54b4358b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
