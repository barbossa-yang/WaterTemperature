; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_uart_fifo.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_uart_fifo.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\RTX\inc -I..\..\RTX\portable -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_uart_fifo.crf ..\..\User\bsp\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;104    */
;;;105    UART_T *ComToUart(COM_PORT_E _ucPort)
000000  4601              MOV      r1,r0
;;;106    {
;;;107    	if (_ucPort == COM1)
000002  b909              CBNZ     r1,|L1.8|
;;;108    	{
;;;109    		#if UART1_FIFO_EN == 1
;;;110    			return &g_tUart1;
000004  4805              LDR      r0,|L1.28|
                  |L1.6|
;;;111    		#else
;;;112    			return 0;
;;;113    		#endif
;;;114    	}
;;;115    	else 
;;;116    	if (_ucPort == COM3)
;;;117    	{
;;;118    		#if UART3_FIFO_EN == 1
;;;119    			return &g_tUart3;
;;;120    		#else
;;;121    			return 0;
;;;122    		#endif
;;;123    	}
;;;124    	else if (_ucPort == COM4)
;;;125    	{
;;;126    		#if UART4_FIFO_EN == 1
;;;127    			return &g_tUart4;
;;;128    		#else
;;;129    			return 0;
;;;130    		#endif
;;;131    	}
;;;132    	else
;;;133    	{
;;;134    		return 0;
;;;135    	}
;;;136    }
000006  4770              BX       lr
                  |L1.8|
000008  2902              CMP      r1,#2                 ;116
00000a  d101              BNE      |L1.16|
00000c  4804              LDR      r0,|L1.32|
00000e  e7fa              B        |L1.6|
                  |L1.16|
000010  2903              CMP      r1,#3                 ;124
000012  d101              BNE      |L1.24|
000014  2000              MOVS     r0,#0                 ;129
000016  e7f6              B        |L1.6|
                  |L1.24|
000018  2000              MOVS     r0,#0                 ;134
00001a  e7f4              B        |L1.6|
;;;137    
                          ENDP

                  |L1.28|
                          DCD      g_tUart1
                  |L1.32|
                          DCD      g_tUart3

                          AREA ||i.ConfigUartNVIC||, CODE, READONLY, ALIGN=1

                  ConfigUartNVIC PROC
;;;605    */
;;;606    static void ConfigUartNVIC(void)
000000  b508              PUSH     {r3,lr}
;;;607    {
;;;608    	NVIC_InitTypeDef NVIC_InitStructure;
;;;609    
;;;610    #if UART1_FIFO_EN == 1
;;;611    	/* 使能串口1中断 */
;;;612    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000002  2025              MOVS     r0,#0x25
000004  f88d0000          STRB     r0,[sp,#0]
;;;613    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
000008  2003              MOVS     r0,#3
00000a  f88d0001          STRB     r0,[sp,#1]
;;;614    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00000e  2000              MOVS     r0,#0
000010  f88d0002          STRB     r0,[sp,#2]
;;;615    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000014  2001              MOVS     r0,#1
000016  f88d0003          STRB     r0,[sp,#3]
;;;616    	NVIC_Init(&NVIC_InitStructure);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       NVIC_Init
;;;617    #endif
;;;618    
;;;619    #if UART2_FIFO_EN == 1
;;;620    	/* 使能串口2中断 */
;;;621    	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
000020  2026              MOVS     r0,#0x26
000022  f88d0000          STRB     r0,[sp,#0]
;;;622    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;
000026  2004              MOVS     r0,#4
000028  f88d0001          STRB     r0,[sp,#1]
;;;623    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00002c  2000              MOVS     r0,#0
00002e  f88d0002          STRB     r0,[sp,#2]
;;;624    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000032  2001              MOVS     r0,#1
000034  f88d0003          STRB     r0,[sp,#3]
;;;625    	NVIC_Init(&NVIC_InitStructure);
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       NVIC_Init
;;;626    #endif
;;;627    
;;;628    #if UART3_FIFO_EN == 1
;;;629    	/* 使能串口3中断t */
;;;630    	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
00003e  2027              MOVS     r0,#0x27
000040  f88d0000          STRB     r0,[sp,#0]
;;;631    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;	
000044  2005              MOVS     r0,#5
000046  f88d0001          STRB     r0,[sp,#1]
;;;632    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00004a  2000              MOVS     r0,#0
00004c  f88d0002          STRB     r0,[sp,#2]
;;;633    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000050  2001              MOVS     r0,#1
000052  f88d0003          STRB     r0,[sp,#3]
;;;634    	NVIC_Init(&NVIC_InitStructure);
000056  4668              MOV      r0,sp
000058  f7fffffe          BL       NVIC_Init
;;;635    #endif
;;;636    
;;;637    #if UART4_FIFO_EN == 1
;;;638    	/* 使能串口4中断t */
;;;639    	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
;;;640    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 7;	
;;;641    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;642    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;643    	NVIC_Init(&NVIC_InitStructure);
;;;644    #endif
;;;645    
;;;646    #if UART5_FIFO_EN == 1
;;;647    	/* 使能串口5中断t */
;;;648    	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
00005c  2035              MOVS     r0,#0x35
00005e  f88d0000          STRB     r0,[sp,#0]
;;;649    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 6;
000062  2006              MOVS     r0,#6
000064  f88d0001          STRB     r0,[sp,#1]
;;;650    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000068  2000              MOVS     r0,#0
00006a  f88d0002          STRB     r0,[sp,#2]
;;;651    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00006e  2001              MOVS     r0,#1
000070  f88d0003          STRB     r0,[sp,#3]
;;;652    	NVIC_Init(&NVIC_InitStructure);
000074  4668              MOV      r0,sp
000076  f7fffffe          BL       NVIC_Init
;;;653    #endif
;;;654    
;;;655    }
00007a  bd08              POP      {r3,pc}
;;;656    
                          ENDP


                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;399    
;;;400    static void InitHardUart(void)
000000  b500              PUSH     {lr}
;;;401    {
000002  b085              SUB      sp,sp,#0x14
;;;402    	GPIO_InitTypeDef GPIO_InitStructure;
;;;403    	USART_InitTypeDef USART_InitStructure;
;;;404    
;;;405    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 */
;;;406    	
;;;407    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;408    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;409    
;;;410    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_9;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;411    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;412    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
000024  f88d0012          STRB     r0,[sp,#0x12]
;;;413    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  a904              ADD      r1,sp,#0x10
00002a  4898              LDR      r0,|L3.652|
00002c  f7fffffe          BL       GPIO_Init
;;;414    
;;;415    	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_10;
000030  f44f6080          MOV      r0,#0x400
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;416    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  2004              MOVS     r0,#4
00003a  f88d0013          STRB     r0,[sp,#0x13]
;;;417    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00003e  a904              ADD      r1,sp,#0x10
000040  4892              LDR      r0,|L3.652|
000042  f7fffffe          BL       GPIO_Init
;;;418    	
;;;419    	USART_InitStructure.USART_BaudRate   = UART1_BAUD;	
000046  f44f30e1          MOV      r0,#0x1c200
00004a  9000              STR      r0,[sp,#0]
;;;420    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00004c  2000              MOVS     r0,#0
00004e  f8ad0004          STRH     r0,[sp,#4]
;;;421    	USART_InitStructure.USART_StopBits   = USART_StopBits_1;
000052  f8ad0006          STRH     r0,[sp,#6]
;;;422    	USART_InitStructure.USART_Parity     = USART_Parity_No ;
000056  f8ad0008          STRH     r0,[sp,#8]
;;;423    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005a  f8ad000c          STRH     r0,[sp,#0xc]
;;;424    	USART_InitStructure.USART_Mode       = USART_Mode_Rx | USART_Mode_Tx;
00005e  200c              MOVS     r0,#0xc
000060  f8ad000a          STRH     r0,[sp,#0xa]
;;;425    	USART_Init(USART1, &USART_InitStructure);
000064  4669              MOV      r1,sp
000066  488a              LDR      r0,|L3.656|
000068  f7fffffe          BL       USART_Init
;;;426    
;;;427    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	
00006c  2201              MOVS     r2,#1
00006e  f2405125          MOV      r1,#0x525
000072  4887              LDR      r0,|L3.656|
000074  f7fffffe          BL       USART_ITConfig
;;;428    
;;;429    	USART_Cmd(USART1, ENABLE);		
000078  2101              MOVS     r1,#1
00007a  4885              LDR      r0,|L3.656|
00007c  f7fffffe          BL       USART_Cmd
;;;430    
;;;431    	USART_ClearFlag(USART1, USART_FLAG_TC);    
000080  2140              MOVS     r1,#0x40
000082  4883              LDR      r0,|L3.656|
000084  f7fffffe          BL       USART_ClearFlag
;;;432    #endif
;;;433    
;;;434    #if UART2_FIFO_EN == 1		/* 串口2 TX = PA2， RX = PA3  */
;;;435    
;;;436    	{
;;;437    		RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);
000088  2101              MOVS     r1,#1
00008a  2008              MOVS     r0,#8
00008c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;438    
;;;439    		GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
000090  2010              MOVS     r0,#0x10
000092  f88d0013          STRB     r0,[sp,#0x13]
;;;440    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000096  2003              MOVS     r0,#3
000098  f88d0012          STRB     r0,[sp,#0x12]
;;;441    		GPIO_InitStructure.GPIO_Pin   = PIN_RS485_TXEN;
00009c  f44f7080          MOV      r0,#0x100
0000a0  f8ad0010          STRH     r0,[sp,#0x10]
;;;442    		GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
0000a4  a904              ADD      r1,sp,#0x10
0000a6  487b              LDR      r0,|L3.660|
0000a8  f7fffffe          BL       GPIO_Init
;;;443    		
;;;444    		RS485_RX_EN();
0000ac  f44f7080          MOV      r0,#0x100
0000b0  4978              LDR      r1,|L3.660|
0000b2  3114              ADDS     r1,r1,#0x14
0000b4  6008              STR      r0,[r1,#0]
;;;445    		
;;;446    		RCC_APB2PeriphClockCmd(RCC_RS485_CTRL, ENABLE);
0000b6  2101              MOVS     r1,#1
0000b8  2040              MOVS     r0,#0x40
0000ba  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;447    
;;;448    		GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
0000be  2010              MOVS     r0,#0x10
0000c0  f88d0013          STRB     r0,[sp,#0x13]
;;;449    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000c4  2003              MOVS     r0,#3
0000c6  f88d0012          STRB     r0,[sp,#0x12]
;;;450    		GPIO_InitStructure.GPIO_Pin   = RS485_1_CTRL | RS485_2_CTRL | RS485_3_CTRL | RS485_4_CTRL;
0000ca  f44f5070          MOV      r0,#0x3c00
0000ce  f8ad0010          STRH     r0,[sp,#0x10]
;;;451    		GPIO_Init(PORT_RS485_CTRL, &GPIO_InitStructure);		
0000d2  a904              ADD      r1,sp,#0x10
0000d4  4870              LDR      r0,|L3.664|
0000d6  f7fffffe          BL       GPIO_Init
;;;452    		
;;;453    		
;;;454    		RS485_1_CTRL_EN();
0000da  f44f6080          MOV      r0,#0x400
0000de  496d              LDR      r1,|L3.660|
0000e0  3110              ADDS     r1,r1,#0x10
0000e2  6008              STR      r0,[r1,#0]
;;;455    		RS485_2_CTRL_NA();
0000e4  0040              LSLS     r0,r0,#1
0000e6  1d09              ADDS     r1,r1,#4
0000e8  6008              STR      r0,[r1,#0]
;;;456    		RS485_3_CTRL_NA();
0000ea  0040              LSLS     r0,r0,#1
0000ec  6008              STR      r0,[r1,#0]
;;;457    		RS485_4_CTRL_NA();		
0000ee  0040              LSLS     r0,r0,#1
0000f0  6008              STR      r0,[r1,#0]
;;;458    		
;;;459    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
0000f2  2101              MOVS     r1,#1
0000f4  2005              MOVS     r0,#5
0000f6  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;460    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
0000fa  2101              MOVS     r1,#1
0000fc  0448              LSLS     r0,r1,#17
0000fe  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;461    
;;;462    		GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2;
000102  2004              MOVS     r0,#4
000104  f8ad0010          STRH     r0,[sp,#0x10]
;;;463    		GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
000108  2018              MOVS     r0,#0x18
00010a  f88d0013          STRB     r0,[sp,#0x13]
;;;464    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00010e  2003              MOVS     r0,#3
000110  f88d0012          STRB     r0,[sp,#0x12]
;;;465    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000114  a904              ADD      r1,sp,#0x10
000116  485d              LDR      r0,|L3.652|
000118  f7fffffe          BL       GPIO_Init
;;;466    
;;;467    		GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_3;
00011c  2008              MOVS     r0,#8
00011e  f8ad0010          STRH     r0,[sp,#0x10]
;;;468    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000122  2004              MOVS     r0,#4
000124  f88d0013          STRB     r0,[sp,#0x13]
;;;469    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000128  a904              ADD      r1,sp,#0x10
00012a  4858              LDR      r0,|L3.652|
00012c  f7fffffe          BL       GPIO_Init
;;;470    
;;;471    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000130  a904              ADD      r1,sp,#0x10
000132  4856              LDR      r0,|L3.652|
000134  f7fffffe          BL       GPIO_Init
;;;472    	}
;;;473    
;;;474    	USART_InitStructure.USART_BaudRate   = UART2_BAUD;	
000138  f44f5016          MOV      r0,#0x2580
00013c  9000              STR      r0,[sp,#0]
;;;475    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00013e  2000              MOVS     r0,#0
000140  f8ad0004          STRH     r0,[sp,#4]
;;;476    	USART_InitStructure.USART_StopBits   = USART_StopBits_1;
000144  f8ad0006          STRH     r0,[sp,#6]
;;;477    	USART_InitStructure.USART_Parity     = USART_Parity_No ;
000148  f8ad0008          STRH     r0,[sp,#8]
;;;478    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00014c  f8ad000c          STRH     r0,[sp,#0xc]
;;;479    	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;		
000150  200c              MOVS     r0,#0xc
000152  f8ad000a          STRH     r0,[sp,#0xa]
;;;480    	USART_Init(USART2, &USART_InitStructure);
000156  4669              MOV      r1,sp
000158  4850              LDR      r0,|L3.668|
00015a  f7fffffe          BL       USART_Init
;;;481    
;;;482    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	
00015e  2201              MOVS     r2,#1
000160  f2405125          MOV      r1,#0x525
000164  484d              LDR      r0,|L3.668|
000166  f7fffffe          BL       USART_ITConfig
;;;483    
;;;484    	USART_Cmd(USART2, ENABLE);		
00016a  2101              MOVS     r1,#1
00016c  484b              LDR      r0,|L3.668|
00016e  f7fffffe          BL       USART_Cmd
;;;485    
;;;486    	USART_ClearFlag(USART2, USART_FLAG_TC);     
000172  2140              MOVS     r1,#0x40
000174  4849              LDR      r0,|L3.668|
000176  f7fffffe          BL       USART_ClearFlag
;;;487    #endif
;;;488    
;;;489    #if UART3_FIFO_EN == 1			/* 串口3 TX = PB10   RX = PB11 */
;;;490    
;;;491    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
00017a  2101              MOVS     r1,#1
00017c  2009              MOVS     r0,#9
00017e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;492    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
000182  2101              MOVS     r1,#1
000184  0488              LSLS     r0,r1,#18
000186  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;493    
;;;494    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_10;
00018a  f44f6080          MOV      r0,#0x400
00018e  f8ad0010          STRH     r0,[sp,#0x10]
;;;495    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
000192  2018              MOVS     r0,#0x18
000194  f88d0013          STRB     r0,[sp,#0x13]
;;;496    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000198  2003              MOVS     r0,#3
00019a  f88d0012          STRB     r0,[sp,#0x12]
;;;497    	GPIO_Init(GPIOB, &GPIO_InitStructure);
00019e  a904              ADD      r1,sp,#0x10
0001a0  483c              LDR      r0,|L3.660|
0001a2  f7fffffe          BL       GPIO_Init
;;;498    
;;;499    	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_11;
0001a6  f44f6000          MOV      r0,#0x800
0001aa  f8ad0010          STRH     r0,[sp,#0x10]
;;;500    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0001ae  2004              MOVS     r0,#4
0001b0  f88d0013          STRB     r0,[sp,#0x13]
;;;501    	GPIO_Init(GPIOB, &GPIO_InitStructure);
0001b4  a904              ADD      r1,sp,#0x10
0001b6  4837              LDR      r0,|L3.660|
0001b8  f7fffffe          BL       GPIO_Init
;;;502    
;;;503    	GPIO_Init(GPIOB, &GPIO_InitStructure);
0001bc  a904              ADD      r1,sp,#0x10
0001be  4835              LDR      r0,|L3.660|
0001c0  f7fffffe          BL       GPIO_Init
;;;504    
;;;505    	USART_InitStructure.USART_BaudRate   = UART3_BAUD;	
0001c4  f44f30e1          MOV      r0,#0x1c200
0001c8  9000              STR      r0,[sp,#0]
;;;506    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0001ca  2000              MOVS     r0,#0
0001cc  f8ad0004          STRH     r0,[sp,#4]
;;;507    	USART_InitStructure.USART_StopBits   = USART_StopBits_1;
0001d0  f8ad0006          STRH     r0,[sp,#6]
;;;508    	USART_InitStructure.USART_Parity     = USART_Parity_No ;
0001d4  f8ad0008          STRH     r0,[sp,#8]
;;;509    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0001d8  f8ad000c          STRH     r0,[sp,#0xc]
;;;510    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0001dc  200c              MOVS     r0,#0xc
0001de  f8ad000a          STRH     r0,[sp,#0xa]
;;;511    	USART_Init(USART3, &USART_InitStructure);
0001e2  4669              MOV      r1,sp
0001e4  482e              LDR      r0,|L3.672|
0001e6  f7fffffe          BL       USART_Init
;;;512    
;;;513    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
0001ea  2201              MOVS     r2,#1
0001ec  f2405125          MOV      r1,#0x525
0001f0  482b              LDR      r0,|L3.672|
0001f2  f7fffffe          BL       USART_ITConfig
;;;514    
;;;515    	USART_Cmd(USART3, ENABLE);		
0001f6  2101              MOVS     r1,#1
0001f8  4829              LDR      r0,|L3.672|
0001fa  f7fffffe          BL       USART_Cmd
;;;516    
;;;517    	USART_ClearFlag(USART3, USART_FLAG_TC);     
0001fe  2140              MOVS     r1,#0x40
000200  4827              LDR      r0,|L3.672|
000202  f7fffffe          BL       USART_ClearFlag
;;;518    #endif
;;;519    
;;;520    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;521    
;;;522    	{
;;;523    		RCC_APB2PeriphClockCmd(RCC_RS485_TXEN2, ENABLE);
;;;524    		
;;;525    		GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
;;;526    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;527    		GPIO_InitStructure.GPIO_Pin   = PORT_RS485_TXEN2;
;;;528    		GPIO_Init(PIN_RS485_TXEN2, &GPIO_InitStructure);
;;;529    			
;;;530    		RCC_APB2PeriphClockCmd(RCC_Bluetooth_CTRL, ENABLE);
;;;531    		
;;;532    //		GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
;;;533    //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;534    //		GPIO_InitStructure.GPIO_Pin   = PIN_Bluetooth_CTRL;
;;;535    //		GPIO_Init(PORT_Bluetooth_CTRL , &GPIO_InitStructure);	
;;;536    //		
;;;537    //		Bluetooth_CTRL_EN();
;;;538    	}	
;;;539    	
;;;540    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
;;;541    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
;;;542    
;;;543    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_10;
;;;544    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
;;;545    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;546    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;547    
;;;548    	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_11;
;;;549    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;550    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;551    
;;;552    	USART_InitStructure.USART_BaudRate   = UART4_BAUD;	
;;;553    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;554    	USART_InitStructure.USART_StopBits   = USART_StopBits_1;
;;;555    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;556    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;557    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;558    	USART_Init(UART4, &USART_InitStructure);
;;;559    
;;;560    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	
;;;561    
;;;562    	USART_Cmd(UART4, ENABLE);		
;;;563    
;;;564    	USART_ClearFlag(UART4, USART_FLAG_TC);     
;;;565    #endif
;;;566    
;;;567    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;568    
;;;569    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
000206  2101              MOVS     r1,#1
000208  2031              MOVS     r0,#0x31
00020a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;570    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
00020e  2101              MOVS     r1,#1
000210  0508              LSLS     r0,r1,#20
000212  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;571    
;;;572    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_12;
000216  f44f5080          MOV      r0,#0x1000
00021a  f8ad0010          STRH     r0,[sp,#0x10]
;;;573    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
00021e  2018              MOVS     r0,#0x18
000220  f88d0013          STRB     r0,[sp,#0x13]
;;;574    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000224  2003              MOVS     r0,#3
000226  f88d0012          STRB     r0,[sp,#0x12]
;;;575    	GPIO_Init(GPIOC, &GPIO_InitStructure);
00022a  a904              ADD      r1,sp,#0x10
00022c  481d              LDR      r0,|L3.676|
00022e  f7fffffe          BL       GPIO_Init
;;;576    
;;;577    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000232  2004              MOVS     r0,#4
000234  f8ad0010          STRH     r0,[sp,#0x10]
;;;578    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000238  f88d0013          STRB     r0,[sp,#0x13]
;;;579    	GPIO_Init(GPIOD, &GPIO_InitStructure);
00023c  a904              ADD      r1,sp,#0x10
00023e  481a              LDR      r0,|L3.680|
000240  f7fffffe          BL       GPIO_Init
;;;580    
;;;581    
;;;582    	USART_InitStructure.USART_BaudRate   = UART5_BAUD;	
000244  f44f5016          MOV      r0,#0x2580
000248  9000              STR      r0,[sp,#0]
;;;583    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00024a  2000              MOVS     r0,#0
00024c  f8ad0004          STRH     r0,[sp,#4]
;;;584    	USART_InitStructure.USART_StopBits   = USART_StopBits_1;
000250  f8ad0006          STRH     r0,[sp,#6]
;;;585    	USART_InitStructure.USART_Parity     = USART_Parity_No ;
000254  f8ad0008          STRH     r0,[sp,#8]
;;;586    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000258  f8ad000c          STRH     r0,[sp,#0xc]
;;;587    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00025c  200c              MOVS     r0,#0xc
00025e  f8ad000a          STRH     r0,[sp,#0xa]
;;;588    	USART_Init(UART5, &USART_InitStructure);
000262  4669              MOV      r1,sp
000264  4811              LDR      r0,|L3.684|
000266  f7fffffe          BL       USART_Init
;;;589    
;;;590    	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	
00026a  2201              MOVS     r2,#1
00026c  f2405125          MOV      r1,#0x525
000270  480e              LDR      r0,|L3.684|
000272  f7fffffe          BL       USART_ITConfig
;;;591    
;;;592    	USART_Cmd(UART5, ENABLE);		
000276  2101              MOVS     r1,#1
000278  480c              LDR      r0,|L3.684|
00027a  f7fffffe          BL       USART_Cmd
;;;593    
;;;594    	USART_ClearFlag(UART5, USART_FLAG_TC);     
00027e  2140              MOVS     r1,#0x40
000280  480a              LDR      r0,|L3.684|
000282  f7fffffe          BL       USART_ClearFlag
;;;595    #endif
;;;596    }
000286  b005              ADD      sp,sp,#0x14
000288  bd00              POP      {pc}
;;;597    
                          ENDP

00028a  0000              DCW      0x0000
                  |L3.652|
                          DCD      0x40010800
                  |L3.656|
                          DCD      0x40013800
                  |L3.660|
                          DCD      0x40010c00
                  |L3.664|
                          DCD      0x40011800
                  |L3.668|
                          DCD      0x40004400
                  |L3.672|
                          DCD      0x40004800
                  |L3.676|
                          DCD      0x40011000
                  |L3.680|
                          DCD      0x40011400
                  |L3.684|
                          DCD      0x40005000

                          AREA ||i.RS485_InitTXE||, CODE, READONLY, ALIGN=2

                  RS485_InitTXE PROC
;;;300    */
;;;301    void RS485_InitTXE(void)
000000  b508              PUSH     {r3,lr}
;;;302    {
;;;303    	GPIO_InitTypeDef GPIO_InitStructure;
;;;304    
;;;305    	RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;306    
;;;307    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;308    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;309    	GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
000016  0100              LSLS     r0,r0,#4
000018  f8ad0000          STRH     r0,[sp,#0]
;;;310    	GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L4.40|
000020  f7fffffe          BL       GPIO_Init
;;;311    }
000024  bd08              POP      {r3,pc}
;;;312    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      0x40010c00

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;980    #if UART1_FIFO_EN == 1
;;;981    void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;982    {
;;;983    	UartIRQ(&g_tUart1);
000002  4802              LDR      r0,|L5.12|
000004  f7fffffe          BL       UartIRQ
;;;984    }
000008  bd10              POP      {r4,pc}
;;;985    #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      g_tUart1

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;987    #if UART3_FIFO_EN == 1
;;;988    void USART3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;989    {
;;;990    	UartIRQ(&g_tUart3);
000002  4802              LDR      r0,|L6.12|
000004  f7fffffe          BL       UartIRQ
;;;991    }
000008  bd10              POP      {r4,pc}
;;;992    #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L6.12|
                          DCD      g_tUart3

                          AREA ||i.Uart1GetChar||, CODE, READONLY, ALIGN=1

                  Uart1GetChar PROC
;;;687    
;;;688    static uint8_t Uart1GetChar(UART_T *_pUart, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;689    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;690    	uint16_t usCount;
;;;691    
;;;692    	DISABLE_INT();
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       __set_PRIMASK
;;;693    		usCount = _pUart->usRxCount;
00000c  8b66              LDRH     r6,[r4,#0x1a]
;;;694    	ENABLE_INT();
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       __set_PRIMASK
;;;695    
;;;696    	if (usCount == 0)	
000014  b90e              CBNZ     r6,|L7.26|
;;;697    	{
;;;698    		return 0;
000016  2000              MOVS     r0,#0
                  |L7.24|
;;;699    	}
;;;700    	else
;;;701    	{
;;;702    		*_pByte = toupper(_pUart->pRxBuf[_pUart->usRxRead]);		
;;;703    
;;;704    		DISABLE_INT();
;;;705    			if (++_pUart->usRxRead >= _pUart->usRxBufSize)
;;;706    			{
;;;707    				_pUart->usRxRead = 0;
;;;708    			}
;;;709    			_pUart->usRxCount--;
;;;710    		ENABLE_INT();
;;;711    			
;;;712    		return 1;
;;;713    	}
;;;714    }
000018  bd70              POP      {r4-r6,pc}
                  |L7.26|
00001a  8b22              LDRH     r2,[r4,#0x18]         ;702
00001c  68a1              LDR      r1,[r4,#8]            ;702
00001e  5c88              LDRB     r0,[r1,r2]            ;702
000020  f7fffffe          BL       toupper
000024  7028              STRB     r0,[r5,#0]            ;702
000026  2001              MOVS     r0,#1                 ;704
000028  f7fffffe          BL       __set_PRIMASK
00002c  8b20              LDRH     r0,[r4,#0x18]         ;705
00002e  1c40              ADDS     r0,r0,#1              ;705
000030  b280              UXTH     r0,r0                 ;705
000032  8320              STRH     r0,[r4,#0x18]         ;705
000034  89e1              LDRH     r1,[r4,#0xe]          ;705
000036  4288              CMP      r0,r1                 ;705
000038  db01              BLT      |L7.62|
00003a  2000              MOVS     r0,#0                 ;707
00003c  8320              STRH     r0,[r4,#0x18]         ;707
                  |L7.62|
00003e  8b60              LDRH     r0,[r4,#0x1a]         ;709
000040  1e40              SUBS     r0,r0,#1              ;709
000042  8360              STRH     r0,[r4,#0x1a]         ;709
000044  2000              MOVS     r0,#0                 ;710
000046  f7fffffe          BL       __set_PRIMASK
00004a  2001              MOVS     r0,#1                 ;712
00004c  e7e4              B        |L7.24|
;;;715    
                          ENDP


                          AREA ||i.Uart3GetChar||, CODE, READONLY, ALIGN=1

                  Uart3GetChar PROC
;;;742    
;;;743    static uint8_t Uart3GetChar(UART_T *_pUart, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;744    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;745    	uint16_t usCount;
;;;746    
;;;747    	DISABLE_INT();
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       __set_PRIMASK
;;;748    		usCount = _pUart->usRxCount;
00000c  8b66              LDRH     r6,[r4,#0x1a]
;;;749    	ENABLE_INT();
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       __set_PRIMASK
;;;750    
;;;751    	if (usCount == 0)	
000014  b90e              CBNZ     r6,|L8.26|
;;;752    	{
;;;753    		return 0;
000016  2000              MOVS     r0,#0
                  |L8.24|
;;;754    	}
;;;755    	else
;;;756    	{
;;;757    		*_pByte = _pUart->pRxBuf[_pUart->usRxRead];		
;;;758    
;;;759    		DISABLE_INT();
;;;760    			if (++_pUart->usRxRead >= _pUart->usRxBufSize)
;;;761    			{
;;;762    				_pUart->usRxRead = 0;
;;;763    			}
;;;764    			_pUart->usRxCount--;
;;;765    		ENABLE_INT();
;;;766    			
;;;767    		return 1;
;;;768    	}
;;;769    }
000018  bd70              POP      {r4-r6,pc}
                  |L8.26|
00001a  8b21              LDRH     r1,[r4,#0x18]         ;757
00001c  68a0              LDR      r0,[r4,#8]            ;757
00001e  5c40              LDRB     r0,[r0,r1]            ;757
000020  7028              STRB     r0,[r5,#0]            ;757
000022  2001              MOVS     r0,#1                 ;759
000024  f7fffffe          BL       __set_PRIMASK
000028  8b20              LDRH     r0,[r4,#0x18]         ;760
00002a  1c40              ADDS     r0,r0,#1              ;760
00002c  b280              UXTH     r0,r0                 ;760
00002e  8320              STRH     r0,[r4,#0x18]         ;760
000030  89e1              LDRH     r1,[r4,#0xe]          ;760
000032  4288              CMP      r0,r1                 ;760
000034  db01              BLT      |L8.58|
000036  2000              MOVS     r0,#0                 ;762
000038  8320              STRH     r0,[r4,#0x18]         ;762
                  |L8.58|
00003a  8b60              LDRH     r0,[r4,#0x1a]         ;764
00003c  1e40              SUBS     r0,r0,#1              ;764
00003e  8360              STRH     r0,[r4,#0x1a]         ;764
000040  2000              MOVS     r0,#0                 ;765
000042  f7fffffe          BL       __set_PRIMASK
000046  2001              MOVS     r0,#1                 ;767
000048  e7e6              B        |L8.24|
;;;770    
                          ENDP


                          AREA ||i.UartGetChar||, CODE, READONLY, ALIGN=1

                  UartGetChar PROC
;;;657    /********************************************************************************/
;;;658    static uint8_t UartGetChar(UART_T *_pUart, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;659    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;660    	uint16_t usCount;
;;;661    
;;;662    	/* usRxWrite 变量在中断函数中被改写，主程序读取该变量时，必须进行临界区保护 */
;;;663    	DISABLE_INT();
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       __set_PRIMASK
;;;664    	usCount = _pUart->usRxCount;
00000c  8b66              LDRH     r6,[r4,#0x1a]
;;;665    	ENABLE_INT();
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       __set_PRIMASK
;;;666    
;;;667    	if (usCount == 0)	/* 已经没有数据 */
000014  b90e              CBNZ     r6,|L9.26|
;;;668    	{
;;;669    		return 0;
000016  2000              MOVS     r0,#0
                  |L9.24|
;;;670    	}
;;;671    	else
;;;672    	{
;;;673    		*_pByte = _pUart->pRxBuf[_pUart->usRxRead];		/* 从串口接收FIFO取1个数据 */
;;;674    
;;;675    		/* 改写FIFO读索引 */
;;;676    		DISABLE_INT();
;;;677    		if (++_pUart->usRxRead >= _pUart->usRxBufSize)
;;;678    		{
;;;679    			_pUart->usRxRead = 0;
;;;680    		}
;;;681    		_pUart->usRxCount--;
;;;682    		ENABLE_INT();
;;;683    		return 1;
;;;684    	}
;;;685    }
000018  bd70              POP      {r4-r6,pc}
                  |L9.26|
00001a  8b21              LDRH     r1,[r4,#0x18]         ;673
00001c  68a0              LDR      r0,[r4,#8]            ;673
00001e  5c40              LDRB     r0,[r0,r1]            ;673
000020  7028              STRB     r0,[r5,#0]            ;673
000022  2001              MOVS     r0,#1                 ;676
000024  f7fffffe          BL       __set_PRIMASK
000028  8b20              LDRH     r0,[r4,#0x18]         ;677
00002a  1c40              ADDS     r0,r0,#1              ;677
00002c  b280              UXTH     r0,r0                 ;677
00002e  8320              STRH     r0,[r4,#0x18]         ;677
000030  89e1              LDRH     r1,[r4,#0xe]          ;677
000032  4288              CMP      r0,r1                 ;677
000034  db01              BLT      |L9.58|
000036  2000              MOVS     r0,#0                 ;679
000038  8320              STRH     r0,[r4,#0x18]         ;679
                  |L9.58|
00003a  8b60              LDRH     r0,[r4,#0x1a]         ;681
00003c  1e40              SUBS     r0,r0,#1              ;681
00003e  8360              STRH     r0,[r4,#0x1a]         ;681
000040  2000              MOVS     r0,#0                 ;682
000042  f7fffffe          BL       __set_PRIMASK
000046  2001              MOVS     r0,#1                 ;683
000048  e7e6              B        |L9.24|
;;;686    
                          ENDP


                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;865    
;;;866    static void UartIRQ(UART_T *_pUart)
000000  b510              PUSH     {r4,lr}
;;;867    {
000002  4604              MOV      r4,r0
;;;868    	if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
000004  f2405125          MOV      r1,#0x525
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b1e0              CBZ      r0,|L10.74|
;;;869    	{
;;;870    		_pUart->pRxBuf[_pUart->usRxWrite] = USART_ReceiveData(_pUart->uart);
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       USART_ReceiveData
000016  8ae2              LDRH     r2,[r4,#0x16]
000018  68a1              LDR      r1,[r4,#8]
00001a  5488              STRB     r0,[r1,r2]
;;;871    		
;;;872    		if (++_pUart->usRxWrite >= _pUart->usRxBufSize)
00001c  8ae0              LDRH     r0,[r4,#0x16]
00001e  1c40              ADDS     r0,r0,#1
000020  b280              UXTH     r0,r0
000022  82e0              STRH     r0,[r4,#0x16]
000024  89e1              LDRH     r1,[r4,#0xe]
000026  4288              CMP      r0,r1
000028  db01              BLT      |L10.46|
;;;873    		{
;;;874    			_pUart->usRxWrite = 0;
00002a  2000              MOVS     r0,#0
00002c  82e0              STRH     r0,[r4,#0x16]
                  |L10.46|
;;;875    		}
;;;876    		
;;;877    		if (_pUart->usRxCount < _pUart->usRxBufSize)
00002e  8b60              LDRH     r0,[r4,#0x1a]
000030  89e1              LDRH     r1,[r4,#0xe]
000032  4288              CMP      r0,r1
000034  da02              BGE      |L10.60|
;;;878    		{
;;;879    			_pUart->usRxCount++;
000036  8b60              LDRH     r0,[r4,#0x1a]
000038  1c40              ADDS     r0,r0,#1
00003a  8360              STRH     r0,[r4,#0x1a]
                  |L10.60|
;;;880    		}
;;;881    
;;;882    		if (_pUart->usRxCount == 1)
00003c  8b60              LDRH     r0,[r4,#0x1a]
00003e  2801              CMP      r0,#1
000040  d103              BNE      |L10.74|
;;;883    		{
;;;884    			if (_pUart->ReciveNew)
000042  6a60              LDR      r0,[r4,#0x24]
000044  b108              CBZ      r0,|L10.74|
;;;885    			{
;;;886    				_pUart->ReciveNew();
000046  6a60              LDR      r0,[r4,#0x24]
000048  4780              BLX      r0
                  |L10.74|
;;;887    			}
;;;888    		}		
;;;889    	}
;;;890    
;;;891    	if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
00004a  f2407127          MOV      r1,#0x727
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       USART_GetITStatus
000054  b308              CBZ      r0,|L10.154|
;;;892    	{
;;;893    		if (_pUart->usTxCount == 0)
000056  8aa0              LDRH     r0,[r4,#0x14]
000058  b960              CBNZ     r0,|L10.116|
;;;894    		{
;;;895    			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
00005a  2200              MOVS     r2,#0
00005c  f2407127          MOV      r1,#0x727
000060  6820              LDR      r0,[r4,#0]
000062  f7fffffe          BL       USART_ITConfig
;;;896    
;;;897    			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
000066  2201              MOVS     r2,#1
000068  f2406126          MOV      r1,#0x626
00006c  6820              LDR      r0,[r4,#0]
00006e  f7fffffe          BL       USART_ITConfig
000072  e037              B        |L10.228|
                  |L10.116|
;;;898    		}
;;;899    		else
;;;900    		{
;;;901    			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
000074  8a63              LDRH     r3,[r4,#0x12]
000076  6862              LDR      r2,[r4,#4]
000078  5cd1              LDRB     r1,[r2,r3]
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       USART_SendData
;;;902    			
;;;903    			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
000080  8a60              LDRH     r0,[r4,#0x12]
000082  1c40              ADDS     r0,r0,#1
000084  b280              UXTH     r0,r0
000086  8260              STRH     r0,[r4,#0x12]
000088  89a1              LDRH     r1,[r4,#0xc]
00008a  4288              CMP      r0,r1
00008c  db01              BLT      |L10.146|
;;;904    			{
;;;905    				_pUart->usTxRead = 0;
00008e  2000              MOVS     r0,#0
000090  8260              STRH     r0,[r4,#0x12]
                  |L10.146|
;;;906    			}
;;;907    			
;;;908    			_pUart->usTxCount--;
000092  8aa0              LDRH     r0,[r4,#0x14]
000094  1e40              SUBS     r0,r0,#1
000096  82a0              STRH     r0,[r4,#0x14]
000098  e024              B        |L10.228|
                  |L10.154|
;;;909    		}
;;;910    
;;;911    	}
;;;912    	else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
00009a  f2406126          MOV      r1,#0x626
00009e  6820              LDR      r0,[r4,#0]
0000a0  f7fffffe          BL       USART_GetITStatus
0000a4  b1f0              CBZ      r0,|L10.228|
;;;913    	{
;;;914    		if (_pUart->usTxCount == 0)
0000a6  8aa0              LDRH     r0,[r4,#0x14]
0000a8  b950              CBNZ     r0,|L10.192|
;;;915    		{
;;;916    			USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
0000aa  2200              MOVS     r2,#0
0000ac  f2406126          MOV      r1,#0x626
0000b0  6820              LDR      r0,[r4,#0]
0000b2  f7fffffe          BL       USART_ITConfig
;;;917    			
;;;918    			if (_pUart->SendOver)
0000b6  6a20              LDR      r0,[r4,#0x20]
0000b8  b1a0              CBZ      r0,|L10.228|
;;;919    			{
;;;920    				_pUart->SendOver();
0000ba  6a20              LDR      r0,[r4,#0x20]
0000bc  4780              BLX      r0
0000be  e011              B        |L10.228|
                  |L10.192|
;;;921    			}
;;;922    		}
;;;923    		else
;;;924    		{
;;;925    			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
0000c0  8a63              LDRH     r3,[r4,#0x12]
0000c2  6862              LDR      r2,[r4,#4]
0000c4  5cd1              LDRB     r1,[r2,r3]
0000c6  6820              LDR      r0,[r4,#0]
0000c8  f7fffffe          BL       USART_SendData
;;;926    			
;;;927    			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
0000cc  8a60              LDRH     r0,[r4,#0x12]
0000ce  1c40              ADDS     r0,r0,#1
0000d0  b280              UXTH     r0,r0
0000d2  8260              STRH     r0,[r4,#0x12]
0000d4  89a1              LDRH     r1,[r4,#0xc]
0000d6  4288              CMP      r0,r1
0000d8  db01              BLT      |L10.222|
;;;928    			{
;;;929    				_pUart->usTxRead = 0;
0000da  2000              MOVS     r0,#0
0000dc  8260              STRH     r0,[r4,#0x12]
                  |L10.222|
;;;930    			}
;;;931    			
;;;932    			_pUart->usTxCount--;
0000de  8aa0              LDRH     r0,[r4,#0x14]
0000e0  1e40              SUBS     r0,r0,#1
0000e2  82a0              STRH     r0,[r4,#0x14]
                  |L10.228|
;;;933    		}
;;;934    	}
;;;935    }
0000e4  bd10              POP      {r4,pc}
;;;936    
                          ENDP


                          AREA ||i.UartSend||, CODE, READONLY, ALIGN=1

                  UartSend PROC
;;;939    
;;;940    static void UartSend(UART_T *_pUart, uint8_t *_ucaBuf, uint16_t _usLen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;941    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;942    	uint16_t i;
;;;943    
;;;944    	for (i = 0; i < _usLen; i++)
000008  2500              MOVS     r5,#0
00000a  e02f              B        |L11.108|
                  |L11.12|
;;;945    	{
;;;946    		while (1)
00000c  e014              B        |L11.56|
                  |L11.14|
;;;947    		{
;;;948    			__IO uint16_t usCount;
;;;949    
;;;950    			DISABLE_INT();
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       __set_PRIMASK
;;;951    				usCount = _pUart->usTxCount;
000014  8aa0              LDRH     r0,[r4,#0x14]
000016  9000              STR      r0,[sp,#0]
;;;952    			ENABLE_INT();
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       __set_PRIMASK
;;;953    
;;;954    			if (usCount < _pUart->usTxBufSize)
00001e  89a0              LDRH     r0,[r4,#0xc]
000020  f8bd1000          LDRH     r1,[sp,#0]
000024  4288              CMP      r0,r1
000026  dd00              BLE      |L11.42|
;;;955    			{
;;;956    				break;
000028  e007              B        |L11.58|
                  |L11.42|
;;;957    			}
;;;958    			else
;;;959    			{
;;;960    				USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
00002a  2201              MOVS     r2,#1
00002c  f2407127          MOV      r1,#0x727
000030  6820              LDR      r0,[r4,#0]
000032  f7fffffe          BL       USART_ITConfig
;;;961    			}			
;;;962    		}
000036  bf00              NOP      
                  |L11.56|
000038  e7e9              B        |L11.14|
                  |L11.58|
00003a  bf00              NOP                            ;956
;;;963    
;;;964    		_pUart->pTxBuf[_pUart->usTxWrite] = _ucaBuf[i];
00003c  5d70              LDRB     r0,[r6,r5]
00003e  8a22              LDRH     r2,[r4,#0x10]
000040  6861              LDR      r1,[r4,#4]
000042  5488              STRB     r0,[r1,r2]
;;;965    
;;;966    		DISABLE_INT();
000044  2001              MOVS     r0,#1
000046  f7fffffe          BL       __set_PRIMASK
;;;967    			if (++_pUart->usTxWrite >= _pUart->usTxBufSize)
00004a  8a20              LDRH     r0,[r4,#0x10]
00004c  1c40              ADDS     r0,r0,#1
00004e  b280              UXTH     r0,r0
000050  8220              STRH     r0,[r4,#0x10]
000052  89a1              LDRH     r1,[r4,#0xc]
000054  4288              CMP      r0,r1
000056  db01              BLT      |L11.92|
;;;968    			{
;;;969    				_pUart->usTxWrite = 0;
000058  2000              MOVS     r0,#0
00005a  8220              STRH     r0,[r4,#0x10]
                  |L11.92|
;;;970    			}
;;;971    			_pUart->usTxCount++;
00005c  8aa0              LDRH     r0,[r4,#0x14]
00005e  1c40              ADDS     r0,r0,#1
000060  82a0              STRH     r0,[r4,#0x14]
;;;972    		ENABLE_INT();
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       __set_PRIMASK
000068  1c68              ADDS     r0,r5,#1              ;944
00006a  b285              UXTH     r5,r0                 ;944
                  |L11.108|
00006c  42bd              CMP      r5,r7                 ;944
00006e  dbcd              BLT      |L11.12|
;;;973    	}
;;;974    
;;;975    	USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
000070  2201              MOVS     r2,#1
000072  f2407127          MOV      r1,#0x727
000076  6820              LDR      r0,[r4,#0]
000078  f7fffffe          BL       USART_ITConfig
;;;976    }
00007c  bdf8              POP      {r3-r7,pc}
;;;977    
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;333    
;;;334    static void UartVarInit(void)
000000  4816              LDR      r0,|L12.92|
;;;335    {
;;;336    #if UART1_FIFO_EN == 1
;;;337    	g_tUart1.uart = USART1;						/* STM32 串口设备 */
000002  4917              LDR      r1,|L12.96|
000004  6008              STR      r0,[r1,#0]  ; g_tUart1
;;;338    	g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
000006  4817              LDR      r0,|L12.100|
000008  6048              STR      r0,[r1,#4]  ; g_tUart1
;;;339    	g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
00000a  4817              LDR      r0,|L12.104|
00000c  6088              STR      r0,[r1,#8]  ; g_tUart1
;;;340    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00000e  f44f7000          MOV      r0,#0x200
000012  8188              STRH     r0,[r1,#0xc]
;;;341    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000014  2080              MOVS     r0,#0x80
000016  81c8              STRH     r0,[r1,#0xe]
;;;342    	g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
000018  2000              MOVS     r0,#0
00001a  8208              STRH     r0,[r1,#0x10]
;;;343    	g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
00001c  8248              STRH     r0,[r1,#0x12]
;;;344    	g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
00001e  82c8              STRH     r0,[r1,#0x16]
;;;345    	g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
000020  8308              STRH     r0,[r1,#0x18]
;;;346    	g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
000022  8348              STRH     r0,[r1,#0x1a]
;;;347    	g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
000024  8288              STRH     r0,[r1,#0x14]
;;;348    	g_tUart1.SendBefor = 0;						/* 发送数据前的回调函数 */
000026  61c8              STR      r0,[r1,#0x1c]  ; g_tUart1
;;;349    	g_tUart1.SendOver = 0;						/* 发送完毕后的回调函数 */
000028  6208              STR      r0,[r1,#0x20]  ; g_tUart1
;;;350    	g_tUart1.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
00002a  6248              STR      r0,[r1,#0x24]  ; g_tUart1
;;;351    #endif
;;;352    
;;;353    #if UART3_FIFO_EN == 1
;;;354    	g_tUart3.uart = USART3;						/* STM32 串口设备 */
00002c  480f              LDR      r0,|L12.108|
00002e  4910              LDR      r1,|L12.112|
000030  6008              STR      r0,[r1,#0]  ; g_tUart3
;;;355    	g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
000032  4810              LDR      r0,|L12.116|
000034  6048              STR      r0,[r1,#4]  ; g_tUart3
;;;356    	g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
000036  4810              LDR      r0,|L12.120|
000038  6088              STR      r0,[r1,#8]  ; g_tUart3
;;;357    	g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00003a  f44f6080          MOV      r0,#0x400
00003e  8188              STRH     r0,[r1,#0xc]
;;;358    	g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000040  2080              MOVS     r0,#0x80
000042  81c8              STRH     r0,[r1,#0xe]
;;;359    	g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
000044  2000              MOVS     r0,#0
000046  8208              STRH     r0,[r1,#0x10]
;;;360    	g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
000048  8248              STRH     r0,[r1,#0x12]
;;;361    	g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
00004a  82c8              STRH     r0,[r1,#0x16]
;;;362    	g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
00004c  8308              STRH     r0,[r1,#0x18]
;;;363    	g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
00004e  8348              STRH     r0,[r1,#0x1a]
;;;364    	g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */
000050  8288              STRH     r0,[r1,#0x14]
;;;365    	g_tUart3.SendBefor = 0;						/* 发送数据前的回调函数 */
000052  61c8              STR      r0,[r1,#0x1c]  ; g_tUart3
;;;366    	g_tUart3.SendOver = 0;						/* 发送完毕后的回调函数 */
000054  6208              STR      r0,[r1,#0x20]  ; g_tUart3
;;;367    	g_tUart3.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000056  6248              STR      r0,[r1,#0x24]  ; g_tUart3
;;;368    #endif
;;;369    
;;;370    #if UART4_FIFO_EN == 1
;;;371    	g_tUart4.uart = UART4;						/* STM32 串口设备 */
;;;372    	g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
;;;373    	g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
;;;374    	g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;375    	g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;376    	g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;377    	g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
;;;378    	g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;379    	g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
;;;380    	g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
;;;381    	g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */
;;;382    	g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;383    	g_tUart4.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;384    	g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;385    #endif
;;;386    
;;;387    }
000058  4770              BX       lr
;;;388    
                          ENDP

00005a  0000              DCW      0x0000
                  |L12.92|
                          DCD      0x40013800
                  |L12.96|
                          DCD      g_tUart1
                  |L12.100|
                          DCD      g_TxBuf1
                  |L12.104|
                          DCD      g_RxBuf1
                  |L12.108|
                          DCD      0x40004800
                  |L12.112|
                          DCD      g_tUart3
                  |L12.116|
                          DCD      g_TxBuf3
                  |L12.120|
                          DCD      g_RxBuf3

                          AREA ||i.__set_PRIMASK||, CODE, READONLY, ALIGN=1

                  __set_PRIMASK PROC
;;;179     */
;;;180    __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
000000  f3808810          MSR      PRIMASK,r0
;;;181    {
;;;182      register uint32_t __regPriMask         __ASM("primask");
;;;183      __regPriMask = (priMask);
;;;184    }
000004  4770              BX       lr
;;;185    
                          ENDP


                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;32     //定义_sys_exit()以避免使用半主机模式    
;;;33     int _sys_exit(int x) 
000000  4770              BX       lr
;;;34     { 
;;;35     	return x = x; 
;;;36     } 
;;;37     //重定义fputc函数 
                          ENDP


                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;85     */
;;;86     void bsp_InitUart(void)
000000  b510              PUSH     {r4,lr}
;;;87     {
;;;88     	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;89     
;;;90     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
;;;91     
;;;92     	RS485_InitTXE();	/* 配置RS485芯片的发送使能硬件，配置为推挽输出 */
00000a  f7fffffe          BL       RS485_InitTXE
;;;93     
;;;94     	ConfigUartNVIC();	/* 配置串口中断 */
00000e  f7fffffe          BL       ConfigUartNVIC
;;;95     }
000012  bd10              POP      {r4,pc}
;;;96     
                          ENDP


                          AREA ||i.bsp_Set485Baud||, CODE, READONLY, ALIGN=2

                  bsp_Set485Baud PROC
;;;320    */
;;;321    void bsp_Set485Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;322    {
000002  4604              MOV      r4,r0
;;;323    	USART_InitTypeDef USART_InitStructure;
;;;324    
;;;325    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;326    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;327    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;328    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;329    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;330    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;331    	USART_Init(USART2, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L16.40|
000022  f7fffffe          BL       USART_Init
;;;332    }
000026  bd1f              POP      {r0-r4,pc}
;;;333    
                          ENDP

                  |L16.40|
                          DCD      0x40004400

                          AREA ||i.bsp_SetUart1Baud||, CODE, READONLY, ALIGN=2

                  bsp_SetUart1Baud PROC
;;;255    */
;;;256    void bsp_SetUart1Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;257    {
000002  4604              MOV      r4,r0
;;;258    	USART_InitTypeDef USART_InitStructure;
;;;259    
;;;260    	/* 第2步： 配置串口硬件参数 */
;;;261    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;262    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;263    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;264    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;265    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;266    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;267    	USART_Init(USART2, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L17.40|
000022  f7fffffe          BL       USART_Init
;;;268    }
000026  bd1f              POP      {r0-r4,pc}
;;;269    
                          ENDP

                  |L17.40|
                          DCD      0x40004400

                          AREA ||i.bsp_SetUart2Baud||, CODE, READONLY, ALIGN=2

                  bsp_SetUart2Baud PROC
;;;277    */
;;;278    void bsp_SetUart2Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;279    {
000002  4604              MOV      r4,r0
;;;280    	USART_InitTypeDef USART_InitStructure;
;;;281    
;;;282    	/* 第2步： 配置串口硬件参数 */
;;;283    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;284    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;285    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;286    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;287    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;288    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;289    	USART_Init(USART2, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L18.40|
000022  f7fffffe          BL       USART_Init
;;;290    }
000026  bd1f              POP      {r0-r4,pc}
;;;291    
                          ENDP

                  |L18.40|
                          DCD      0x40004400

                          AREA ||i.com1GetChar||, CODE, READONLY, ALIGN=2

                  com1GetChar PROC
;;;715    
;;;716    uint8_t com1GetChar(uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;717    {
000002  4604              MOV      r4,r0
;;;718    	UART_T *pUart =&g_tUart1;
000004  4d04              LDR      r5,|L19.24|
;;;719    
;;;720    	if (pUart == 0)
000006  b90d              CBNZ     r5,|L19.12|
;;;721    	{
;;;722    		return 0;
000008  2000              MOVS     r0,#0
                  |L19.10|
;;;723    	}
;;;724    
;;;725    	return Uart1GetChar(pUart, _pByte);
;;;726    }
00000a  bd70              POP      {r4-r6,pc}
                  |L19.12|
00000c  4621              MOV      r1,r4                 ;725
00000e  4628              MOV      r0,r5                 ;725
000010  f7fffffe          BL       Uart1GetChar
000014  e7f9              B        |L19.10|
;;;727    
                          ENDP

000016  0000              DCW      0x0000
                  |L19.24|
                          DCD      g_tUart1

                          AREA ||i.com1Surplus||, CODE, READONLY, ALIGN=2

                  com1Surplus PROC
;;;727    
;;;728    uint16_t com1Surplus(void)
000000  b510              PUSH     {r4,lr}
;;;729    {
;;;730    	uint16_t count;
;;;731    
;;;732    	DISABLE_INT();
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       __set_PRIMASK
;;;733    		count = UART1_TX_BUF_SIZE - g_tUart1.usTxCount;
000008  4804              LDR      r0,|L20.28|
00000a  8a80              LDRH     r0,[r0,#0x14]  ; g_tUart1
00000c  f5c07000          RSB      r0,r0,#0x200
000010  b284              UXTH     r4,r0
;;;734    	ENABLE_INT();	
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       __set_PRIMASK
;;;735    
;;;736    	return count;	
000018  4620              MOV      r0,r4
;;;737    }
00001a  bd10              POP      {r4,pc}
;;;738    
                          ENDP

                  |L20.28|
                          DCD      g_tUart1

                          AREA ||i.com3GetBuf||, CODE, READONLY, ALIGN=2

                  com3GetBuf PROC
;;;811    
;;;812    uint8_t com3GetBuf( uint8_t *_pBuf, uint16_t len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;813    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
;;;814    	UART_T *_pUart = &g_tUart3;
000008  4c18              LDR      r4,|L21.108|
;;;815    	
;;;816    	uint16_t usCount,i,k;
;;;817    	
;;;818    	if (_pUart == 0)
00000a  b914              CBNZ     r4,|L21.18|
;;;819    	{
;;;820    		return 0;
00000c  2000              MOVS     r0,#0
                  |L21.14|
;;;821    	}
;;;822    	
;;;823    	/* usRxWrite 变量在中断函数中被改写，主程序读取该变量时，必须进行临界区保护 */
;;;824    	DISABLE_INT();
;;;825    	usCount = _pUart->usRxCount;
;;;826    	ENABLE_INT();
;;;827    	
;;;828        if(usCount<len) return 0;//缓冲区没有那么多数，不做操作返回，不会破坏其他的数据结构
;;;829    	
;;;830    	for (i=0;i<len;i++)
;;;831    	{
;;;832    		k=_pUart->usRxRead+i;
;;;833    		if(k>=_pUart->usRxBufSize)k=k-_pUart->usRxBufSize;
;;;834    		_pBuf[i] = _pUart->pRxBuf[k];
;;;835    	}
;;;836    		
;;;837    	/* 改写FIFO读索引 */
;;;838    	DISABLE_INT();	
;;;839    	{
;;;840    		_pUart->usRxRead = k+1;
;;;841    	}
;;;842    	_pUart->usRxCount=_pUart->usRxCount-len;
;;;843    
;;;844    	ENABLE_INT();
;;;845    
;;;846    	return 1;
;;;847    
;;;848    }
00000e  e8bd87f0          POP      {r4-r10,pc}
                  |L21.18|
000012  2001              MOVS     r0,#1                 ;824
000014  f7fffffe          BL       __set_PRIMASK
000018  f8b4901a          LDRH     r9,[r4,#0x1a]         ;825
00001c  2000              MOVS     r0,#0                 ;826
00001e  f7fffffe          BL       __set_PRIMASK
000022  45b1              CMP      r9,r6                 ;828
000024  da01              BGE      |L21.42|
000026  2000              MOVS     r0,#0                 ;828
000028  e7f1              B        |L21.14|
                  |L21.42|
00002a  2500              MOVS     r5,#0                 ;830
00002c  e00e              B        |L21.76|
                  |L21.46|
00002e  8b20              LDRH     r0,[r4,#0x18]         ;832
000030  4428              ADD      r0,r0,r5              ;832
000032  b287              UXTH     r7,r0                 ;832
000034  89e0              LDRH     r0,[r4,#0xe]          ;833
000036  42b8              CMP      r0,r7                 ;833
000038  dc02              BGT      |L21.64|
00003a  89e0              LDRH     r0,[r4,#0xe]          ;833
00003c  1a38              SUBS     r0,r7,r0              ;833
00003e  b287              UXTH     r7,r0                 ;833
                  |L21.64|
000040  68a0              LDR      r0,[r4,#8]            ;834
000042  5dc0              LDRB     r0,[r0,r7]            ;834
000044  f8080005          STRB     r0,[r8,r5]            ;834
000048  1c68              ADDS     r0,r5,#1              ;830
00004a  b285              UXTH     r5,r0                 ;830
                  |L21.76|
00004c  42b5              CMP      r5,r6                 ;830
00004e  dbee              BLT      |L21.46|
000050  2001              MOVS     r0,#1                 ;838
000052  f7fffffe          BL       __set_PRIMASK
000056  1c78              ADDS     r0,r7,#1              ;840
000058  8320              STRH     r0,[r4,#0x18]         ;840
00005a  8b60              LDRH     r0,[r4,#0x1a]         ;842
00005c  1b80              SUBS     r0,r0,r6              ;842
00005e  8360              STRH     r0,[r4,#0x1a]         ;842
000060  2000              MOVS     r0,#0                 ;844
000062  f7fffffe          BL       __set_PRIMASK
000066  2001              MOVS     r0,#1                 ;846
000068  e7d1              B        |L21.14|
;;;849    
                          ENDP

00006a  0000              DCW      0x0000
                  |L21.108|
                          DCD      g_tUart3

                          AREA ||i.com3GetBufLen||, CODE, READONLY, ALIGN=2

                  com3GetBufLen PROC
;;;793    
;;;794    uint16_t com3GetBufLen(void)
000000  b570              PUSH     {r4-r6,lr}
;;;795    {
;;;796    	UART_T *_pUart = &g_tUart3;
000002  4c07              LDR      r4,|L22.32|
;;;797    	
;;;798    	uint16_t usCount=0;
000004  2500              MOVS     r5,#0
;;;799    	
;;;800    	if (_pUart == 0)
000006  b90c              CBNZ     r4,|L22.12|
;;;801    	{
;;;802    		return 0;
000008  2000              MOVS     r0,#0
                  |L22.10|
;;;803    	}
;;;804    	
;;;805    	DISABLE_INT();
;;;806    		usCount = _pUart->usRxCount;
;;;807    	ENABLE_INT();
;;;808    	
;;;809    	return usCount;
;;;810    }
00000a  bd70              POP      {r4-r6,pc}
                  |L22.12|
00000c  2001              MOVS     r0,#1                 ;805
00000e  f7fffffe          BL       __set_PRIMASK
000012  8b65              LDRH     r5,[r4,#0x1a]         ;806
000014  2000              MOVS     r0,#0                 ;807
000016  f7fffffe          BL       __set_PRIMASK
00001a  4628              MOV      r0,r5                 ;809
00001c  e7f5              B        |L22.10|
;;;811    
                          ENDP

00001e  0000              DCW      0x0000
                  |L22.32|
                          DCD      g_tUart3

                          AREA ||i.com3GetChar||, CODE, READONLY, ALIGN=2

                  com3GetChar PROC
;;;770    
;;;771    uint8_t com3GetChar(uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;772    {
000002  4604              MOV      r4,r0
;;;773    	UART_T *pUart = &g_tUart3;
000004  4d04              LDR      r5,|L23.24|
;;;774    
;;;775    	if (pUart == 0)
000006  b90d              CBNZ     r5,|L23.12|
;;;776    	{
;;;777    		return 0;
000008  2000              MOVS     r0,#0
                  |L23.10|
;;;778    	}
;;;779    
;;;780    	return Uart3GetChar(pUart, _pByte);
;;;781    }
00000a  bd70              POP      {r4-r6,pc}
                  |L23.12|
00000c  4621              MOV      r1,r4                 ;780
00000e  4628              MOV      r0,r5                 ;780
000010  f7fffffe          BL       Uart3GetChar
000014  e7f9              B        |L23.10|
;;;782    
                          ENDP

000016  0000              DCW      0x0000
                  |L23.24|
                          DCD      g_tUart3

                          AREA ||i.com3SendBuf||, CODE, READONLY, ALIGN=2

                  com3SendBuf PROC
;;;849    
;;;850    void com3SendBuf(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;851    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;852    	UART_T *pUart = &g_tUart3;;
000006  4c07              LDR      r4,|L24.36|
;;;853    
;;;854    	if (pUart == 0)
000008  b904              CBNZ     r4,|L24.12|
                  |L24.10|
;;;855    	{
;;;856    		return;
;;;857    	}
;;;858    	if (pUart->SendBefor )
;;;859    		pUart->SendBefor() ;
;;;860    	
;;;861    	UartSend(pUart, _ucaBuf, _usLen);
;;;862    }
00000a  bd70              POP      {r4-r6,pc}
                  |L24.12|
00000c  69e0              LDR      r0,[r4,#0x1c]         ;858
00000e  b108              CBZ      r0,|L24.20|
000010  69e0              LDR      r0,[r4,#0x1c]         ;859
000012  4780              BLX      r0                    ;859
                  |L24.20|
000014  4632              MOV      r2,r6                 ;861
000016  4629              MOV      r1,r5                 ;861
000018  4620              MOV      r0,r4                 ;861
00001a  f7fffffe          BL       UartSend
00001e  bf00              NOP      
000020  e7f3              B        |L24.10|
;;;863    
                          ENDP

000022  0000              DCW      0x0000
                  |L24.36|
                          DCD      g_tUart3

                          AREA ||i.com3Surplus||, CODE, READONLY, ALIGN=2

                  com3Surplus PROC
;;;782    
;;;783    uint16_t com3Surplus(void)
000000  b510              PUSH     {r4,lr}
;;;784    {
;;;785    	uint16_t count;
;;;786    
;;;787    	DISABLE_INT();
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       __set_PRIMASK
;;;788    		count = UART3_TX_BUF_SIZE - g_tUart3.usTxCount;
000008  4804              LDR      r0,|L25.28|
00000a  8a80              LDRH     r0,[r0,#0x14]  ; g_tUart3
00000c  f5c06080          RSB      r0,r0,#0x400
000010  b284              UXTH     r4,r0
;;;789    	ENABLE_INT();	
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       __set_PRIMASK
;;;790    
;;;791    	return count;	
000018  4620              MOV      r0,r4
;;;792    }
00001a  bd10              POP      {r4,pc}
;;;793    
                          ENDP

                  |L25.28|
                          DCD      g_tUart3

                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;232    */
;;;233    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;234    {
000002  4603              MOV      r3,r0
;;;235    	UART_T *pUart;
;;;236    
;;;237    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;238    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L26.16|
                  |L26.14|
;;;239    	{
;;;240    		return;
;;;241    	}
;;;242    
;;;243    	pUart->usRxWrite = 0;
;;;244    	pUart->usRxRead = 0;
;;;245    	pUart->usRxCount = 0;
;;;246    }
00000e  bd00              POP      {pc}
                  |L26.16|
000010  2000              MOVS     r0,#0                 ;243
000012  82d0              STRH     r0,[r2,#0x16]         ;243
000014  8310              STRH     r0,[r2,#0x18]         ;244
000016  8350              STRH     r0,[r2,#0x1a]         ;245
000018  bf00              NOP      
00001a  e7f8              B        |L26.14|
;;;247    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;209    */
;;;210    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;211    {
000002  4603              MOV      r3,r0
;;;212    	UART_T *pUart;
;;;213    
;;;214    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;215    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L27.16|
                  |L27.14|
;;;216    	{
;;;217    		return;
;;;218    	}
;;;219    
;;;220    	pUart->usTxWrite = 0;
;;;221    	pUart->usTxRead = 0;
;;;222    	pUart->usTxCount = 0;
;;;223    }
00000e  bd00              POP      {pc}
                  |L27.16|
000010  2000              MOVS     r0,#0                 ;220
000012  8210              STRH     r0,[r2,#0x10]         ;220
000014  8250              STRH     r0,[r2,#0x12]         ;221
000016  8290              STRH     r0,[r2,#0x14]         ;222
000018  bf00              NOP      
00001a  e7f8              B        |L27.14|
;;;224    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;188    */
;;;189    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;190    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;191    	UART_T *pUart;
;;;192    
;;;193    	pUart = ComToUart(_ucPort);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       ComToUart
00000c  4604              MOV      r4,r0
;;;194    	if (pUart == 0)
00000e  b90c              CBNZ     r4,|L28.20|
;;;195    	{
;;;196    		return 0;
000010  2000              MOVS     r0,#0
                  |L28.18|
;;;197    	}
;;;198    
;;;199    	return UartGetChar(pUart, _pByte);
;;;200    }
000012  bd70              POP      {r4-r6,pc}
                  |L28.20|
000014  4631              MOV      r1,r6                 ;199
000016  4620              MOV      r0,r4                 ;199
000018  f7fffffe          BL       UartGetChar
00001c  e7f9              B        |L28.18|
;;;201    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;147    */
;;;148    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;149    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;150    	UART_T *pUart;
;;;151    
;;;152    	pUart = ComToUart(_ucPort);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       ComToUart
000010  4604              MOV      r4,r0
;;;153    	if (pUart == 0)
000012  b90c              CBNZ     r4,|L29.24|
                  |L29.20|
;;;154    	{
;;;155    		return;
;;;156    	}
;;;157    
;;;158    	if (pUart->SendBefor != 0)
;;;159    	{
;;;160    		pUart->SendBefor();		
;;;161    	}
;;;162    
;;;163    	UartSend(pUart, _ucaBuf, _usLen);
;;;164    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L29.24|
000018  69e0              LDR      r0,[r4,#0x1c]         ;158
00001a  b108              CBZ      r0,|L29.32|
00001c  69e0              LDR      r0,[r4,#0x1c]         ;160
00001e  4780              BLX      r0                    ;160
                  |L29.32|
000020  463a              MOV      r2,r7                 ;163
000022  4631              MOV      r1,r6                 ;163
000024  4620              MOV      r0,r4                 ;163
000026  f7fffffe          BL       UartSend
00002a  bf00              NOP      
00002c  e7f2              B        |L29.20|
;;;165    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;174    */
;;;175    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;176    {
000002  4604              MOV      r4,r0
;;;177    	comSendBuf(_ucPort, &_ucByte, 1);
000004  2201              MOVS     r2,#1
000006  a901              ADD      r1,sp,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       comSendBuf
;;;178    }
00000e  bd1c              POP      {r2-r4,pc}
;;;179    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;37     //重定义fputc函数 
;;;38     int fputc(int ch, FILE *f)
000000  bf00              NOP      
                  |L31.2|
;;;39     {      
;;;40     	while((USART1->SR&0X40)==0); //循环发送,直到发送完毕   
000002  4a05              LDR      r2,|L31.24|
000004  8812              LDRH     r2,[r2,#0]
000006  f0120f40          TST      r2,#0x40
00000a  d0fa              BEQ      |L31.2|
;;;41         USART1->DR = (u8) ch;      
00000c  b2c2              UXTB     r2,r0
00000e  4b02              LDR      r3,|L31.24|
000010  1d1b              ADDS     r3,r3,#4
000012  801a              STRH     r2,[r3,#0]
;;;42     	return ch;
;;;43     }
000014  4770              BX       lr
;;;44     #endif 
                          ENDP

000016  0000              DCW      0x0000
                  |L31.24|
                          DCD      0x40013800

                          AREA ||i.getkey||, CODE, READONLY, ALIGN=2

                  getkey PROC
;;;1035   */
;;;1036   int getkey (void)
000000  b510              PUSH     {r4,lr}
;;;1037   {
;;;1038   
;;;1039   #if 0	/* 从串口接收FIFO中取1个数据, 只有取到数据才返回 */
;;;1040   	uint8_t ucData;
;;;1041   
;;;1042   	while(comGetChar(COM1, &ucData) == 0);
;;;1043   
;;;1044   	return ucData;
;;;1045   #else
;;;1046   	/* 等待串口1输入数据 */
;;;1047   	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
000002  bf00              NOP      
                  |L32.4|
000004  2120              MOVS     r1,#0x20
000006  4804              LDR      r0,|L32.24|
000008  f7fffffe          BL       USART_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L32.4|
;;;1048   
;;;1049   	return (int)USART_ReceiveData(USART1);
000010  4801              LDR      r0,|L32.24|
000012  f7fffffe          BL       USART_ReceiveData
;;;1050   #endif
;;;1051   }
000016  bd10              POP      {r4,pc}
;;;1052   
                          ENDP

                  |L32.24|
                          DCD      0x40013800

                          AREA ||i.sendchar||, CODE, READONLY, ALIGN=2

                  sendchar PROC
;;;1008   */
;;;1009   int sendchar(int ch)
000000  b510              PUSH     {r4,lr}
;;;1010   {
000002  4604              MOV      r4,r0
;;;1011   #if 0	/* 将需要printf的字符通过串口中断FIFO发送出去，printf函数会立即返回 */
;;;1012   	comSendChar(COM1, ch);
;;;1013   
;;;1014   	return ch;
;;;1015   #else	/* 采用阻塞方式发送每个字符,等待数据发送完毕 */
;;;1016   	
;;;1017   	/* 等待发送结束 */
;;;1018   	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
000004  bf00              NOP      
                  |L33.6|
000006  2140              MOVS     r1,#0x40
000008  4805              LDR      r0,|L33.32|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L33.6|
;;;1019   	{}
;;;1020   	
;;;1021   	/* 写一个字节到USART1 */
;;;1022   	USART_SendData(USART1, (uint8_t) ch);
000012  b2e1              UXTB     r1,r4
000014  4802              LDR      r0,|L33.32|
000016  f7fffffe          BL       USART_SendData
;;;1023   
;;;1024   	return ch;
00001a  4620              MOV      r0,r4
;;;1025   #endif
;;;1026   }
00001c  bd10              POP      {r4,pc}
;;;1027   
                          ENDP

00001e  0000              DCW      0x0000
                  |L33.32|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        512
                  g_RxBuf1
                          %        128
                  g_tUart3
                          %        40
                  g_TxBuf3
                          %        1024
                  g_RxBuf3
                          %        128

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_9275e5e5____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_uart_fifo_c_9275e5e5____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_9275e5e5____REVSH|
#line 128
|__asm___15_bsp_uart_fifo_c_9275e5e5____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
